<!DOCTYPE html>
<html>

<head>
    <title>Chat App</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <link href="{{ url_for('static', filename='styles.css') }}" rel="stylesheet">
    <!-- Chart.js for interactive charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>

<body>
    <div class="chat-container">
        <div class="chat-header">
            <h5 class="mb-0"><i class="bi bi-database"></i>Chat App</h5>
            <div class="conversation-controls">
                <button class="clear-conversation-btn" onclick="clearConversation()">
                    <i class="bi bi-trash"></i> Clear Chat
                </button>
                <span class="message-counter" id="messageCounter" title="Total messages">0</span>
            </div>
        </div>

        <div class="chat-body" id="chatBody">
            <!-- Messages will be loaded here -->
        </div>

        <div class="loading" id="loading" style="display: none;">
            <div class="spinner"></div>
        </div>

        <div class="chat-footer">
            <input type="text" class="chat-input" id="userInput" placeholder="Ask about your data..."
                autocomplete="off">
            <button class="send-btn" id="sendBtn" onclick="sendMessage()">
                <i class="bi bi-send"></i>
            </button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Global variables
        let conversationHistory = [];
        let useInteractiveCharts = localStorage.getItem('useInteractiveCharts') === 'true'; // Toggle for chart mode
        const DEV_MODE = false; // Set to true to show SQL preview and data preview

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function () {
            loadConversationHistory();
            console.log('Chart mode on load:', useInteractiveCharts ? 'Interactive' : 'Static');

            // Set up event listeners
            document.getElementById('userInput').addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
        });

        // Load conversation history
        function loadConversationHistory() {
            fetch('/conversation_history')
                .then(response => response.json())
                .then(data => {
                    conversationHistory = data.conversation_history || [];

                    // Display conversation history
                    if (conversationHistory.length > 0) {
                        displayConversationHistory(conversationHistory);
                    } else {
                        // Show welcome message if no history
                        addBotMessage("Hello! I'm your database analytics assistant. Ask me anything about your data.");
                    }
                    
                    // Update message counter after displaying
                    updateMessageCounter();
                })
                .catch(error => {
                    console.error('Error loading conversation history:', error);
                    addBotMessage("Hello! I'm your database analytics assistant. Ask me anything about your data.");
                    updateMessageCounter();
                });
        }

        // Display conversation history
        function displayConversationHistory(history) {
            const chatBody = document.getElementById('chatBody');
            chatBody.innerHTML = '';

            history.forEach(conv => {
                addUserMessage(conv.question, conv.timestamp);

                if (conv.response_obj) {
                    const resp = conv.response_obj;
                    switch (resp.type) {
                        case 'text':
                            addBotMessage(resp.content, conv.timestamp);
                            break;
                        case 'card':
                            showCards(resp.content);
                            break;
                        case 'table':
                            showTable(resp.content);
                            break;
                        case 'chart':
                            showChart(resp.content, resp.chart_type, resp.data_preview);
                            break;
                        case 'diagram':
                            showDiagram(resp.content, resp.title);
                            break;
                        default:
                            addBotMessage(resp.content || "I couldn't process your request.", conv.timestamp);
                    }
                    if (DEV_MODE) {
                        if (resp.sql) {
                            addSqlInfo(resp.sql);
                        } else if (conv.sql_query) {
                            addSqlInfo(conv.sql_query);
                        }
                    }
                } else if (conv.response) {
                    // fallback for old history
                    addBotMessage(conv.response, conv.timestamp);
                    if (DEV_MODE && conv.sql_query) {
                        addSqlInfo(conv.sql_query);
                    }
                }
            });
        }

        // Update message counter
        function updateMessageCounter() {
            const chatBody = document.getElementById('chatBody');
            const messages = chatBody.querySelectorAll('.message');
            const counter = document.getElementById('messageCounter');
            counter.textContent = messages.length;
        }

        // Clear conversation
        function clearConversation() {
            if (confirm('Are you sure you want to clear the entire conversation? This action cannot be undone.')) {
                // Clear the chat body
                const chatBody = document.getElementById('chatBody');
                chatBody.innerHTML = '';
                
                // Clear conversation history
                conversationHistory = [];
                
                // Clear from server
                fetch('/clear_conversation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                .then(response => response.json())
                .then(data => {
                    console.log('Conversation cleared:', data);
                })
                .catch(error => {
                    console.error('Error clearing conversation:', error);
                });
                
                // Add welcome message
                addBotMessage("Hello! I'm your database analytics assistant. Ask me anything about your data.");
                
                // Update counter
                updateMessageCounter();
            }
        }

        // Check if message is a greeting
        function isGreeting(message) {
            const greetings = [
                'hi', 'hello', 'hey', 'good morning', 'good afternoon', 'good evening',
                'morning', 'afternoon', 'evening', 'sup', 'what\'s up', 'howdy',
                'greetings', 'salutations', 'yo', 'hi there', 'hello there',
                'good day', 'good night', 'night', 'bye', 'goodbye', 'see you',
                'take care', 'farewell', 'ciao', 'adios', 'au revoir'
            ];
            
            const normalizedMessage = message.toLowerCase().trim();
            return greetings.some(greeting => normalizedMessage.includes(greeting));
        }

        // Get greeting response
        function getGreetingResponse() {
            const responses = [
                "Hello! How can I help you today?",
                "Hi there! What would you like to know?",
                "Hey! How can I assist you?",
                "Greetings! How can I help you today?",
                "Hello! What questions do you have?"
            ];
            
            return responses[Math.floor(Math.random() * responses.length)];
        }

        // Send user message
        function sendMessage() {
            const input = document.getElementById('userInput');
            const message = input.value.trim();

            if (!message) return;

            // Add user message to chat
            addUserMessage(message);
            input.value = '';

            // Check if it's a greeting
            if (isGreeting(message)) {
                // Respond to greeting without calling AI
                setTimeout(() => {
                    addBotMessage(getGreetingResponse());
                }, 500); // Small delay for natural feel
                return;
            }

            // Show loading indicator
            document.getElementById('loading').style.display = 'flex';

            // Scroll to bottom
            scrollToBottom();

            // Send to backend
            fetch('/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    question: message
                })
            })
                .then(response => {
                    console.log('Response status:', response.status);
                    console.log('Response headers:', response.headers);
                    return response.json();
                })
                .then(data => {
                    console.log('Response data:', data);
                    
                    // Hide loading indicator
                    document.getElementById('loading').style.display = 'none';

                    // Validate response data
                    if (!data) {
                        console.error('No data received');
                        addBotMessage("Sorry, no response received from the server.");
                        return;
                    }

                    // Handle different response types
                    console.log('About to handle response type:', data.type);
                    switch (data.type) {
                        case 'text':
                            console.log('Handling text response');
                            addBotMessage(data.content);
                            break;

                        case 'card':
                            console.log('Handling card response');
                            showCards(data.content);
                            break;

                        case 'table':
                            console.log('Handling table response - calling showTable');
                            showTable(data.content);
                            break;

                        case 'chart':
                            console.log('Handling chart response');
                            showChart(data.content, data.chart_type, data.data_preview);
                            break;

                        case 'diagram':
                            console.log('Handling diagram response');
                            showDiagram(data.content, data.title);
                            break;

                        default:
                            console.warn('Unknown response type:', data.type);
                            addBotMessage(data.content || "I couldn't process your request.");
                    }

                    // Add SQL info if available (only in dev mode)
                    if (DEV_MODE && data.sql) {
                        addSqlInfo(data.sql);
                    }

                    // Update conversation count
                    if (data.conversation_count !== undefined) {
                        conversationHistory.length = data.conversation_count;
                        updateMessageCounter();
                    }

                    // Scroll to bottom
                    scrollToBottom();
                })
                .catch(error => {
                    console.error('Fetch error:', error);
                    document.getElementById('loading').style.display = 'none';
                    addBotMessage("Sorry, there was an error processing your request. Please try again.");
                    scrollToBottom();
                });
        }

        // Add user message to chat
        function addUserMessage(message, timestamp = null) {
            const chatBody = document.getElementById('chatBody');
            const now = new Date();
            const timeString = timestamp ? new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user-message';
            messageDiv.innerHTML = `
                <div>${message}</div>
                <div class="message-time">${timeString}</div>
            `;

            chatBody.appendChild(messageDiv);
            updateMessageCounter();
            scrollToBottom();
        }

        // Add bot message to chat
        function addBotMessage(message, timestamp = null) {
            const chatBody = document.getElementById('chatBody');
            const now = new Date();
            const timeString = timestamp ? new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message bot-message';

            // Check if this is a documentation response
            const isDocumentation = message.includes('•') || message.includes('tables') || message.includes('columns') || message.includes('database');

            if (isDocumentation) {
                // Format as documentation response
                const formattedMessage = formatDocumentationResponse(message);
                messageDiv.innerHTML = `
                    <div class="documentation-response">
                        ${formattedMessage}
                    </div>
                    <div class="message-time">${timeString}</div>
                `;
            } else {
                // Format as enhanced text response
                const formattedMessage = formatEnhancedTextResponse(message);
                messageDiv.innerHTML = `
                    <div class="enhanced-text-response">
                        ${formattedMessage}
                    </div>
                    <div class="message-time">${timeString}</div>
                `;
            }

            chatBody.appendChild(messageDiv);
            updateMessageCounter();
            scrollToBottom();
        }

        // Format documentation response
        function formatDocumentationResponse(message) {
            // Convert markdown-style formatting to HTML
            let formatted = message
                // Handle headers (multiple # symbols)
                .replace(/^#{1,6}\s+(.*$)/gim, '<h3>$1</h3>')
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                // Handle bold text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                // Handle italic text
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                // Handle code blocks
                .replace(/`(.*?)`/g, '<code>$1</code>')
                // Handle line breaks
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n• /g, '</li><li>')
                .replace(/^• /, '<li>');

            // Wrap in proper HTML structure
            if (formatted.includes('<li>')) {
                formatted = formatted.replace(/^<li>/, '');
                formatted = formatted.replace(/<\/li>$/, '');
                formatted = `<ul class="documentation-list">${formatted}</ul>`;
            }

            return `<p>${formatted}</p>`;
        }

        // Format enhanced text response
        function formatEnhancedTextResponse(message) {
            // Convert markdown-style formatting to HTML
            let formatted = message
                // Handle headers (multiple # symbols)
                .replace(/^#{1,6}\s+(.*$)/gim, '<h3>$1</h3>')
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                // Handle bold text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                // Handle italic text
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                // Handle code blocks
                .replace(/`(.*?)`/g, '<code>$1</code>')
                // Handle line breaks
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br>');

            return `<p>${formatted}</p>`;
        }

        // Show cards for metrics
        function showCards(cards) {
            const chatBody = document.getElementById('chatBody');
            const now = new Date();
            const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message bot-message';

            let cardsHtml = '<div class="card-container">';
            cards.forEach(card => {
                cardsHtml += `
                    <div class="metric-card">
                        <div class="metric-title">${card.title}</div>
                        <div class="metric-value">${card.value}</div>
                    </div>
                `;
            });
            cardsHtml += '</div>';

            messageDiv.innerHTML = `
                <div>Here are the key metrics:</div>
                ${cardsHtml}
                <div class="message-time">${timeString}</div>
            `;

            chatBody.appendChild(messageDiv);
            updateMessageCounter();
        }

        // Show data table
        function showTable(data) {
            console.log('showTable called with data:', data);
            
            if (!data || data.length === 0) {
                console.log('No data to display');
                addBotMessage("No data found.");
                return;
            }

            const chatBody = document.getElementById('chatBody');
            const now = new Date();
            const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            // Get column names
            const columns = Object.keys(data[0]);
            console.log('Table columns:', columns);

            // Build table HTML
            let tableHtml = '<div class="table-container"><table class="data-table"><thead><tr>';
            columns.forEach(col => {
                tableHtml += `<th>${col}</th>`;
            });
            tableHtml += '</tr></thead><tbody>';

            // Add rows
            data.forEach((row, index) => {
                console.log(`Row ${index}:`, row);
                tableHtml += '<tr>';
                columns.forEach(col => {
                    tableHtml += `<td>${row[col] !== null ? row[col] : 'NULL'}</td>`;
                });
                tableHtml += '</tr>';
            });

            tableHtml += '</tbody></table></div>';

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message bot-message';
            messageDiv.innerHTML = `
                <div>Query results:</div>
                ${tableHtml}
                <div class="table-controls">
                    <button class="download-btn" onclick="downloadTableAsExcel(${JSON.stringify(data).replace(/"/g, '&quot;')})">
                        <i class="bi bi-file-earmark-excel"></i> Download Excel
                    </button>
                    <button class="download-btn" onclick="downloadTableAsPDF(${JSON.stringify(data).replace(/"/g, '&quot;')})">
                        <i class="bi bi-file-earmark-pdf"></i> Download PDF
                    </button>
                </div>
                <div class="message-time">${timeString}</div>
            `;

            console.log('Adding table to chat body');
            chatBody.appendChild(messageDiv);
            console.log('Table added successfully');
            updateMessageCounter();
        }

        // Show chart (with option for interactive charts)
        function showChart(chartData, chartType, dataPreview) {
            const chatBody = document.getElementById('chatBody');
            const now = new Date();
            const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message bot-message';

            // Check if we should use interactive charts (you can toggle this)
            // const useInteractiveCharts = false; // Set to true to use interactive charts

            if (useInteractiveCharts && dataPreview && dataPreview.length > 0) {
                // Create interactive chart using Chart.js
                const chartId = 'chart_' + Date.now();
                let chartHtml = `
                    <div class="chart-container">
                        <canvas id="${chartId}" width="400" height="200"></canvas>
                    </div>
                `;

                messageDiv.innerHTML = `
                    <div>Here's the interactive ${chartType} chart:</div>
                    ${chartHtml}
                    <div class="chart-controls">
                        <button class="chart-mode-btn btn-success" onclick="toggleChartModeForChart(this, '${chartId}', '${chartType}', ${JSON.stringify(dataPreview).replace(/"/g, '&quot;')})">
                            <i class="bi bi-image"></i> Switch to Static
                        </button>
                        <button class="download-btn" onclick="downloadChart('${chartId}', '${chartType}')">
                            <i class="bi bi-download"></i> Download PNG
                        </button>
                    </div>
                    <div class="message-time">${timeString}</div>
                `;

                chatBody.appendChild(messageDiv);

                // Create the interactive chart
                setTimeout(() => {
                    createInteractiveChart(chartId, dataPreview, chartType);
                }, 100);
            } else {
                // Use static image (current behavior)
                let imgSrc = '';
                if (chartData && !chartData.startsWith('iVBOR') && !chartData.startsWith('/9j/')) {
                    imgSrc = `/static/generated/${chartData}`;
                } else {
                    imgSrc = `data:image/png;base64,${chartData}`;
                }

                let chartHtml = `
                    <div class="chart-container">
                        <img class="chart-img" src="${imgSrc}" alt="Chart">
                    </div>
                `;

                messageDiv.innerHTML = `
                    <div>Here's the ${chartType} chart:</div>
                    ${chartHtml}
                    <div class="chart-controls">
                        <button class="chart-mode-btn" onclick="toggleChartModeForChart(this, null, '${chartType}', ${JSON.stringify(dataPreview).replace(/"/g, '&quot;')})">
                            <i class="bi bi-graph-up"></i> Switch to Interactive
                        </button>
                        <button class="download-btn" onclick="downloadChartImage('${chartData}')">
                            <i class="bi bi-download"></i> Download PNG
                        </button>
                    </div>
                    <div class="message-time">${timeString}</div>
                `;

                chatBody.appendChild(messageDiv);
            }

            // Optionally show data preview (only in dev mode)
            if (DEV_MODE && dataPreview && dataPreview.length > 0) {
                addBotMessage("Data preview: " + JSON.stringify(dataPreview));
            }
            updateMessageCounter();
        }

        // Toggle chart mode for a specific chart
        function toggleChartModeForChart(button, chartId, chartType, dataPreview) {
            const chartContainer = button.closest('.message');
            const chartControls = button.closest('.chart-controls');
            const chartContainerDiv = chartContainer.querySelector('.chart-container');
            
            if (useInteractiveCharts) {
                // Switch from interactive to static
                useInteractiveCharts = false;
                localStorage.setItem('useInteractiveCharts', 'false');
                
                // Generate static chart image using the backend
                generateStaticChart(chartType, dataPreview).then(imageData => {
                    if (imageData) {
                        chartContainerDiv.innerHTML = `
                            <img class="chart-img" src="data:image/png;base64,${imageData}" alt="Chart">
                        `;
                        console.log('Static chart generated successfully');
                        
                        // Update chart controls to include download button
                        const chartControls = button.closest('.chart-controls');
                        chartControls.innerHTML = `
                            <button class="chart-mode-btn" onclick="toggleChartModeForChart(this, null, '${chartType}', ${JSON.stringify(dataPreview).replace(/"/g, '&quot;')})">
                                <i class="bi bi-graph-up"></i> Switch to Interactive
                            </button>
                            <button class="download-btn" onclick="downloadChartImage('${imageData}')">
                                <i class="bi bi-download"></i> Download PNG
                            </button>
                        `;
                    } else {
                        // Fallback to a placeholder
                        chartContainerDiv.innerHTML = `
                            <div class="chart-placeholder">
                                <p>Static chart generation failed. Please try again.</p>
                            </div>
                        `;
                        console.warn('Static chart generation returned null');
                    }
                }).catch(error => {
                    console.error('Error generating static chart:', error);
                    chartContainerDiv.innerHTML = `
                        <div class="chart-placeholder">
                            <p>Error generating static chart. Please try again.</p>
                        </div>
                    `;
                });
                
                // Update button
                button.innerHTML = '<i class="bi bi-graph-up"></i> Switch to Interactive';
                button.className = 'chart-mode-btn';
                button.onclick = () => toggleChartModeForChart(button, null, chartType, dataPreview);
                
                console.log('Switched chart to static mode');
            } else {
                // Switch from static to interactive
                useInteractiveCharts = true;
                localStorage.setItem('useInteractiveCharts', 'true');
                
                // Remove image and create canvas
                const newChartId = 'chart_' + Date.now();
                chartContainerDiv.innerHTML = `<canvas id="${newChartId}" width="400" height="200"></canvas>`;
                
                // Update chart controls to include download button
                const chartControls = button.closest('.chart-controls');
                chartControls.innerHTML = `
                    <button class="chart-mode-btn btn-success" onclick="toggleChartModeForChart(this, '${newChartId}', '${chartType}', ${JSON.stringify(dataPreview).replace(/"/g, '&quot;')})">
                        <i class="bi bi-image"></i> Switch to Static
                    </button>
                    <button class="download-btn" onclick="downloadChart('${newChartId}', '${chartType}')">
                        <i class="bi bi-download"></i> Download PNG
                    </button>
                `;
                
                // Create the interactive chart
                setTimeout(() => {
                    createInteractiveChart(newChartId, dataPreview, chartType);
                }, 100);
                
                console.log('Switched chart to interactive mode');
            }
            updateMessageCounter();
        }

        // Toggle between static and interactive charts (global setting)
        function toggleChartMode() {
            useInteractiveCharts = !useInteractiveCharts;
            localStorage.setItem('useInteractiveCharts', useInteractiveCharts.toString());
            updateChartModeButton();
        }

        // Update chart mode button appearance (for global button - now removed)
        function updateChartModeButton() {
            // This function is kept for compatibility but no longer used
            console.log('Global chart mode:', useInteractiveCharts ? 'Interactive' : 'Static');
        }

        // Download chart as PNG (for interactive charts)
        function downloadChart(canvasId, chartType) {
            const canvas = document.getElementById(canvasId);
            if (canvas) {
                const link = document.createElement('a');
                link.download = `${chartType}_chart_${Date.now()}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            } else {
                console.error('Canvas element not found');
            }
        }

        // Download chart image (for static charts)
        function downloadChartImage(imageData) {
            if (imageData && !imageData.startsWith('iVBOR') && !imageData.startsWith('/9j/')) {
                // It's a filename, download from server
                const link = document.createElement('a');
                link.download = imageData;
                link.href = `/static/generated/${imageData}`;
                link.click();
            } else if (imageData) {
                // It's base64 data
                const link = document.createElement('a');
                link.download = `chart_${Date.now()}.png`;
                link.href = `data:image/png;base64,${imageData}`;
                link.click();
            }
        }

        // Download table as Excel
        function downloadTableAsExcel(data) {
            if (!data || data.length === 0) {
                console.error('No data to download');
                return;
            }

            // Create CSV content
            const headers = Object.keys(data[0]);
            const csvContent = [
                headers.join(','),
                ...data.map(row => headers.map(header => {
                    const value = row[header];
                    // Escape quotes and wrap in quotes if contains comma
                    return typeof value === 'string' && value.includes(',') ? 
                        `"${value.replace(/"/g, '""')}"` : value;
                }).join(','))
            ].join('\n');

            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `table_data_${Date.now()}.csv`;
            link.click();
            URL.revokeObjectURL(link.href);
        }

        // Download table as PDF
        function downloadTableAsPDF(data) {
            if (!data || data.length === 0) {
                console.error('No data to download');
                return;
            }

            // Create a simple HTML table for PDF conversion
            const headers = Object.keys(data[0]);
            let tableHtml = `
                <html>
                <head>
                    <style>
                        table { border-collapse: collapse; width: 100%; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        th { background-color: #f2f2f2; }
                    </style>
                </head>
                <body>
                    <h2>Data Export</h2>
                    <table>
                        <thead>
                            <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
                        </thead>
                        <tbody>
                            ${data.map(row => 
                                `<tr>${headers.map(header => `<td>${row[header] || ''}</td>`).join('')}</tr>`
                            ).join('')}
                        </tbody>
                    </table>
                </body>
                </html>
            `;

            // Use browser's print functionality to save as PDF
            const printWindow = window.open('', '_blank');
            printWindow.document.write(tableHtml);
            printWindow.document.close();
            printWindow.focus();
            
            // Wait for content to load then print
            setTimeout(() => {
                printWindow.print();
                printWindow.close();
            }, 500);
        }

        // Generate static chart by calling the backend
        async function generateStaticChart(chartType, dataPreview) {
            try {
                const response = await fetch('/generate_static_chart', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        chart_type: chartType,
                        data: dataPreview
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    return result.image_data;
                } else {
                    console.error('Failed to generate static chart:', response.status);
                    return null;
                }
            } catch (error) {
                console.error('Error calling generate_static_chart:', error);
                return null;
            }
        }

        // Create interactive chart using Chart.js
        function createInteractiveChart(canvasId, data, chartType) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            
            // Prepare data for Chart.js
            const labels = data.map(row => {
                const keys = Object.keys(row);
                return keys.length > 0 ? row[keys[0]] : '';
            });
            
            const values = data.map(row => {
                const keys = Object.keys(row);
                return keys.length > 1 ? parseFloat(row[keys[1]]) || 0 : 0;
            });

            const chartConfig = {
                type: chartType === 'bar' ? 'bar' : 
                      chartType === 'line' ? 'line' : 
                      chartType === 'pie' ? 'pie' : 'scatter',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Data',
                        data: values,
                        backgroundColor: chartType === 'pie' ? 
                            ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'] :
                            'rgba(54, 162, 235, 0.2)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${chartType.charAt(0).toUpperCase() + chartType.slice(1)} Chart`
                        }
                    }
                }
            };

            new Chart(ctx, chartConfig);
        }

        // Show diagram
        function showDiagram(content, title) {
            const chatBody = document.getElementById('chatBody');
            const now = new Date();
            const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message bot-message';

            // If content looks like a filename (not base64), use static path
            let imgSrc = '';
            if (content && !content.startsWith('iVBOR') && !content.startsWith('/9j/')) {
                imgSrc = `/static/generated/${content}`;
            } else {
                imgSrc = `data:image/png;base64,${content}`;
            }

            let diagramHtml = `
                <div class="diagram-container">
                    <div class="diagram-title">${title}</div>
                    <img class="diagram-img" src="${imgSrc}" alt="${title}">
                </div>
            `;

            messageDiv.innerHTML = `
                <div>Here's the ${title} diagram:</div>
                ${diagramHtml}
                <div class="message-time">${timeString}</div>
            `;

            chatBody.appendChild(messageDiv);
            updateMessageCounter();
        }

        // Add SQL information
        function addSqlInfo(sql) {
            if (!DEV_MODE) return; // Only show SQL in dev mode
            
            const chatBody = document.getElementById('chatBody');

            const sqlDiv = document.createElement('div');
            sqlDiv.className = 'message bot-message';
            sqlDiv.innerHTML = `
                <div class="toggle-sql" onclick="toggleSql(this)">Show SQL <i class="bi bi-chevron-down"></i></div>
                <div class="sql-info" style="display: none;">${sql}</div>
            `;

            chatBody.appendChild(sqlDiv);
            updateMessageCounter();
            scrollToBottom();
        }

        // Toggle SQL visibility
        function toggleSql(element) {
            const sqlInfo = element.nextElementSibling;
            const icon = element.querySelector('i');

            if (sqlInfo.style.display === 'none') {
                sqlInfo.style.display = 'block';
                icon.className = 'bi bi-chevron-up';
                element.innerHTML = element.innerHTML.replace('Show', 'Hide');
            } else {
                sqlInfo.style.display = 'none';
                icon.className = 'bi bi-chevron-down';
                element.innerHTML = element.innerHTML.replace('Hide', 'Show');
            }

            scrollToBottom();
        }

        // Scroll chat to bottom
        function scrollToBottom() {
            const chatBody = document.getElementById('chatBody');
            chatBody.scrollTop = chatBody.scrollHeight;
        }

        // Clear conversation
        function clearConversation() {
            fetch('/clear_conversation', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
                .then(response => response.json())
                .then(data => {
                    // Clear the chat display
                    const chatBody = document.getElementById('chatBody');
                    chatBody.innerHTML = '';

                    // Reset conversation history
                    conversationHistory = [];
                    updateMessageCounter();

                    // Show welcome message
                    addBotMessage("Hello! I'm your database analytics assistant. Ask me anything about your data.");
                })
                .catch(error => {
                    console.error('Error clearing conversation:', error);
                    addBotMessage("Sorry, there was an error clearing the conversation.");
                });
        }

        // Test response format
        // function testResponse() {
        //     console.log('Testing response format...');
        //     fetch('/test_response')
        //         .then(response => response.json())
        //         .then(data => {
        //             console.log('Test response data:', data);
        //             
        //             // Handle different response types
        //             switch (data.type) {
        //                 case 'text':
        //                     addBotMessage(data.content);
        //                     break;
        //                 case 'card':
        //                     showCards(data.content);
        //                     break;
        //                 case 'table':
        //                     showTable(data.content);
        //                     break;
        //                 case 'chart':
        //                     showChart(data.content, data.chart_type, data.data_preview);
        //                     break;
        //                 case 'diagram':
        //                     showDiagram(data.content, data.title);
        //                     break;
        //                 default:
        //                     console.warn('Unknown response type:', data.type);
        //                     addBotMessage(data.content || "I couldn't process your request.");
        //             }

        //             // Add SQL info if available
        //             if (data.sql) {
        //                 addSqlInfo(data.sql);
        //             }

        //             // Update conversation count
        //             if (data.conversation_count !== undefined) {
        //                 conversationHistory.length = data.conversation_count;
        //                 updateConversationCount();
        //             }

        //             // Scroll to bottom
        //             scrollToBottom();
        //         })
        //         .catch(error => {
        //             console.error('Test response error:', error);
        //             addBotMessage("Sorry, there was an error testing the response.");
        //         });
        // }
    </script>
</body>

</html>